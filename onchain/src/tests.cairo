use core::option::OptionTrait;
use core::starknet::SyscallResultTrait;
use core::traits::TryInto;
use openzeppelin::presets::ERC20Upgradeable;
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::utils::cryptography::snip12::{OffchainMessageHashImpl, OffchainMessageHash};
use openzeppelin::utils::serde::SerializedAppend;
use starknet::secp256_trait::{recover_public_key, Secp256PointTrait, Signature, is_valid_signature};
use starknet::secp256r1::{Secp256r1Point, Secp256r1PointImpl};
use starknet::testing::set_contract_address;
use starknet::{ContractAddress, deploy_syscall, contract_address_const};
use starknet::{secp256r1::Secp256r1Impl};
use vault::contracts::account::{Account, IVaultAccountDispatcher, IVaultAccountDispatcherTrait};
use vault::misc::claim::{ClaimLinkTraitDispatcher, ClaimLinkTraitDispatcherTrait, Claim};
use vault::misc::snip12::SNIP12MetadataImpl;

/// Deploys a mock erc20 contract.
fn deploy_erc20(recipient: ContractAddress, initial_supply: u256) -> IERC20Dispatcher {
    let name: ByteArray = "Fake token";
    let symbol: ByteArray = "FT";
    let mut calldata = array![];

    calldata.append_serde(name);
    calldata.append_serde(symbol);
    calldata.append_serde(2 * initial_supply);
    calldata.append_serde(recipient);
    calldata.append_serde(recipient);

    let (address, _) = deploy_syscall(
        ERC20Upgradeable::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
    )
        .unwrap_syscall();
    IERC20Dispatcher { contract_address: address }
}

fn deploy_vault_account() -> ContractAddress {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), true
    )
        .unwrap_syscall();

    let (pub_key_x, pub_key_y) = PUBLIC_KEY;

    IVaultAccountDispatcher { contract_address: address }
        .initialize(:pub_key_x, :pub_key_y, approver: contract_address_const::<0>(), limit: LIMIT);

    return address;
}

const PUBLIC_KEY: (u256, u256) =
    (
        0xed5784a75391dc43adcd42dbc4c938e80690c75b3f4309049d5076692f8dafe9,
        0x7ed5e8b3d94dd41f677d0e25f6ea5b332495bbdb74923eabbe9e7d2c1d09a08a
    );
const LIMIT: u256 = 0x1000000000000;
const AMOUNT: u256 = 0x123456789;

// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;

const R: u256 = 0xecd7c9a9ac973a68de272e4fa06ff71fa9779b5ea9c782ee84c6926c711ccc94;
const S: u256 = 0x3807b572e157c4904493999a77758fbebc5b01486c2c8533c3882ec79439f24;

fn valid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(R);
    sig.append_serde(S);
    sig
}

fn invalid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(S);
    sig.append_serde(R);
    sig
}

#[test]
fn test_claim_link_valid_signature_not_already_claimed_works() {
    let address = deploy_vault_account();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}

#[test]
#[should_panic(expected: ("Invalid signature for claim", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_invalid_signature_not_already_claimed_fails() {
    let address = deploy_vault_account();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    // println!("hash: {}", Claim { amount: AMOUNT, nonce: 0 }.get_message_hash(address));

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: invalid_signature());
}

#[test]
#[should_panic(expected: ("Link already used", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_valid_signature_already_claimed_fails() {
    let address = deploy_vault_account();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}
