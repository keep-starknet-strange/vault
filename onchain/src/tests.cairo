use core::option::OptionTrait;
use core::starknet::SyscallResultTrait;
use core::traits::TryInto;
use openzeppelin::presets::ERC20Upgradeable;
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::utils::cryptography::snip12::{OffchainMessageHashImpl, OffchainMessageHash};
use openzeppelin::utils::serde::SerializedAppend;
use starknet::secp256_trait::{recover_public_key, Secp256PointTrait, Signature, is_valid_signature};
use starknet::secp256r1::{Secp256r1Point, Secp256r1PointImpl};
use starknet::testing::set_contract_address;
use starknet::{ContractAddress, deploy_syscall, contract_address_const};
use starknet::{secp256r1::Secp256r1Impl};
use vault::contracts::account::Account::SNIP12MetadataImpl;
use vault::contracts::account::Account;
use vault::misc::claim::{ClaimLinkTraitDispatcher, ClaimLinkTraitDispatcherTrait, Claim};

/// Deploys a mock erc20 contract.
fn deploy_erc20(recipient: ContractAddress, initial_supply: u256) -> IERC20Dispatcher {
    let name: ByteArray = "Fake token";
    let symbol: ByteArray = "FT";
    let mut calldata = array![];

    calldata.append_serde(name);
    calldata.append_serde(symbol);
    calldata.append_serde(2 * initial_supply);
    calldata.append_serde(recipient);
    calldata.append_serde(recipient);

    let (address, _) = deploy_syscall(
        ERC20Upgradeable::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
    )
        .unwrap_syscall();
    IERC20Dispatcher { contract_address: address }
}

const PUBLIC_KEY: (u256, u256) =
    (
        0xed5784a75391dc43adcd42dbc4c938e80690c75b3f4309049d5076692f8dafe9,
        0x7ed5e8b3d94dd41f677d0e25f6ea5b332495bbdb74923eabbe9e7d2c1d09a08a
    );
const LIMIT: u256 = 0x1000000000000;
const AMOUNT: u256 = 0x123456789;

// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;

const R: u256 = 0x4904ab51199af5502e0416ecb3337ba53e48663063db10d08639adc93516f6c5;
const S: u256 = 0x9d96f40ee3f7e17ec7d55ff960f6379a2dfe267f06db09ad81c283b270dd6404;

fn valid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(R);
    sig.append_serde(S);
    sig
}

fn invalid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(S);
    sig.append_serde(R);
    sig
}

fn approver() -> ContractAddress {
    contract_address_const::<0x0>()
}

fn constructor_calldata() -> Array<felt252> {
    let mut res = array![];
    res.append_serde(PUBLIC_KEY);
    res.append_serde(approver());
    res.append_serde(LIMIT);
    res
}

#[test]
fn test_claim_link_valid_signature_not_already_claimed_works() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}

#[test]
#[should_panic(expected: ("Invalid signature for claim", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_invalid_signature_not_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    // println!("hash: {}", Claim { amount: AMOUNT, nonce: 0 }.get_message_hash(address));

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: invalid_signature());
}

#[test]
#[should_panic(expected: ("Link already used", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_valid_signature_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);

    set_contract_address(contract_address_const::<0x1>());

    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}
