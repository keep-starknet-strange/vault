use openzeppelin::utils::serde::SerializedAppend;

const P256_PUBLIC_KEY: (u256, u256) =
    (
        0xed5784a75391dc43adcd42dbc4c938e80690c75b3f4309049d5076692f8dafe9,
        0x7ed5e8b3d94dd41f677d0e25f6ea5b332495bbdb74923eabbe9e7d2c1d09a08a
    );

const LIMIT: u256 = 0x1000000000000;
const AMOUNT: u256 = 0x123456789;

// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;

mod P256_SIGNATURE {
    const R: u256 = 0xeeaa86daaad4be7c1de32963cb6aaac83d177e3244f076d849fe2d7bd4707232;
    const S: u256 = 0xb95ab7445b7456036ea751db94ef9532fac8861249179f8b51a8e64c4443a267;
}

const PUBLIC_KEY: felt252 = 0x1f3c942d7f492a37608cde0d77b884a5aa9e11d2919225968557370ddb5a5aa;

fn VALID_SIGNATURE() -> Array<felt252> {
    let mut sig = array![];

    sig.append_serde(P256_SIGNATURE::R);
    sig.append_serde(P256_SIGNATURE::S);

    sig
}

fn INVALID_SIGNATURE() -> Array<felt252> {
    let mut sig = array![];

    sig.append_serde(P256_SIGNATURE::S);
    sig.append_serde(P256_SIGNATURE::R);

    sig
}

//
// ERC20
//

const SUPPLY: u256 = 1_000_000_000_000_000_000; // 1 ETH

fn NAME() -> ByteArray {
    "NAME"
}

fn SYMBOL() -> ByteArray {
    "SYMBOL"
}
